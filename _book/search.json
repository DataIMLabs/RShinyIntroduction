[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introductie R en Shiny",
    "section": "",
    "text": "Index",
    "crumbs": [
      "Index"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introductie",
    "section": "",
    "text": "Welkom bij de introductiecursus R en Shiny. Doel van de cursus is om jouw kennis van R en Shiny op het gebied van data-analyse en visualisatie te verrijken.\nWe zullen eenvoudige en meer geavanceerde R-technieken behandelen, steeds in de context van wat nuttig en nodig is bij het opzetten van Shiny dashboards. Aan de hand van praktijkvoorbeelden en case-studies begeleiden we je bij het ontwikkelen van eigen projecten in R, variërend van eenvoudige statische apps die data visualiseren tot complexe applicaties met uitgebreide gebruikersinteracties.\nDe cursus bestaat uit vijf modules:\n\nModule 1 geeft een introductie in de basisprincipes van R. Veel van wat hier besproken wordt zal voor de meeste datawetenschappers bekend zijn. Toch raden wij aan deze module met zorg door te werken.\nModule 2 bespreekt beknopt hoe wij werken met data bij het opzetten van dashboards. We richten ons (enkel) op de technieken en packages die voor het bouwen van productiedashboards nuttig zijn. Zo verkiezen we het data.table package boven tidyverse vanwege de superieure performance van data.table.\nModule 3 gaat in op het maken van grafieken met het plotly package. Hier hebben wij wederom en keuze gemaakt uit de vele verschillende mogelijkheden die in het R ecosysteem geboden worden. Degenen met ervaring ggplot2 kunnen deze kennis blijven inzetten: plotly biedt de mogelijkheid om de meeste (statische) ggplot2-grafieken te converteren naar plotly-charts.\nModule 4 behandelt enkele meer geavanceerde R technieken die later zullen terugkomen bij het opstellen van Shiny dashboards. Ingegaan wordt op het gebruik van R6-classes en objecten, het gebruik van iteratoren\nModule 5 behandelt de basisprincipes van Shiny\nModule 6 gaat in op het modulair opzetten van een Shiny dashboard",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introductie</span>"
    ]
  },
  {
    "objectID": "mod1_basis.html",
    "href": "mod1_basis.html",
    "title": "Module 1 - Basis R",
    "section": "",
    "text": "In deze module verkennen we de basisconcepten van R die essentieel zijn voor data-analyse, data-manipulatie en het maken van dashboards in Shiny.\nWe behandelen achtereenvolgens de volgende thema’s:\n\nhet werken met variabelen, operatoren en functies\nde verschillende datatypes in R\nhet ophalen van elementen uit collecties (subsetting)\nvoorwaardelijke- en herhaalde uitvoer van code (flow-control).\n\nOok voor degenen die al enige ervaring hebben met R kan het geen kwaad deze onderwerpen nog eens door te nemen. Bij de hiernavolgende modules veronderstellen we bekendheid met bovengenoemde thema’s.",
    "crumbs": [
      "Module 1 - Basis R"
    ]
  },
  {
    "objectID": "mod1_variables.html",
    "href": "mod1_variables.html",
    "title": "2  Variablen, operatoren en functies.",
    "section": "",
    "text": "2.1 Variabelen\nEen variabele is een verwijzing naar een waarde in het geheugden van de computer. Een variabele in R bestaat uit twee onderdelen, namelijk de naam van de variabele en de waarde van de variabele. De (binaire) operatoren &lt;-, &lt;&lt;-, -&gt; en -&gt;&gt; creëren variabelen door een naam toe te kennen aan een waarde.\nVoorbeelden:\nVariabelen worden altijd gedefiniëerd in een bepaalde context (environment). Het ls()-commando geeft weer welke variabelen gedefiniëerd zijn in de huidige werkomgeving.\nIn de hiernavolgende paragrafen gaan we nader in op enkele meer geavanceerde onderwerpen die betrekking hebben op het werken met variabelen in R, te weten:\nDit zijn geen eenvoudige onderwerpen, maar voor een goed begrip van complexe R Scripts en Shiny-dashboards zijn deze onderwerpen essentiëel. We raden aan de onderdelen met een asterisk op een later moment nog eens te bezien.",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variablen, operatoren en functies.</span>"
    ]
  },
  {
    "objectID": "mod1_variables.html#variabelen",
    "href": "mod1_variables.html#variabelen",
    "title": "2  Variablen, operatoren en functies.",
    "section": "",
    "text": "x1 &lt;- 5\nx2 &lt;- c(1,2,3)\nx3 &lt;- list(\"a\", \"b\", \"c\")\nx4 &lt;- function(x){\n    print(x)\n}\n\n\n\nde context waarin variabelen bestaan (scopes en environments)\nmutabiliteit en locks (*)\ndynamische types (*)\ncopy-on-modify semantiek (*).\n\n\n\n2.1.1 Scopes en environments\nDe scope van een variabele geeft aan in welke context de variabele bestaat. In R heet een dergelijke context ook wel een environment. Dit hoofdstuk beperkt zich tot deze betekenis van het begrip environment; later zullen we zien dat een environment niet enkel een abstract concept is, maar (ook) een datatype waar we handig gebruik van kunnen maken. Twee voorbeelden hiervan zijn zogeheten R6-reference klasses en Shiny reactives.\nHieronder vatten we de hoofdpunten samen:\n\nDe belangrijkste scope is de zogeheten globale environment. Dit is de omgeving waarin men werkt gedurende een interactieve R sessie; ook een R script of Shiny-sessie wordt uitgevoerd in deze scope. De globale environment kan worden benaderd via het keyword .GlobalEnv of via de functie globalenv().\nFuncties creëren hun eigen lokale omgeving—een zogeheten execution-environment—met daarin de variabelen die (enkel) binnen de context van de functie betekenis hebben.\nZodra een functie wordt uitgevoerd ontstaat een koppeling tussen de execution-environment van de functie en de omgeving waar de functie werd aangeroepen—de zogeheten calling-environment.\nDe plek waar een functie is aangemaakt is de zogeheten enclosing-environment van de functie.\n\nEnkele nuttige functies voor het doorzoeken van een omgeving:\n\n\n\n\n\n\n\nSyntax\nOmschrijving\n\n\n\n\nassign()\nWijs een waarde toe aan een naam in een environment\n\n\nget()\nHaal de waarde van een bepaalde naam op uit een environment\n\n\nls()\nGeef de objecten weer in de huidige scope. Door het argument envir aan te passen kan de scope waarin gezocht wordt worden aangepasrt.\n\n\nrm(list=ls())\nMaak de huidige scope leeg\n\n\n.GlobalEnv\nDe globale omgeving als ‘object’\n\n\n\n\n\nQuizAntwoord\n\n\nZie de functie f in onderstaande codevoorbeeld. Wat zou je op de ... in f kunnen invullen zodat de variabele x uit de bovenliggende omgeving wordt opgezocht en niet de variabele x in de functieomgeving?\nx &lt;- 2\n\nf &lt;- function(){\n    x &lt;- 10\n    print(...) \n}\n\nf()\n\n\nDoor op de ... het commando get() te gebruiken in combinatie met het envir-argument kun je bepalen in welke omgeving x opgezocht moet worden. In dit geval volstaat het om als envir de waarde .GlobalEnv te nemen. Noot: we hadden ook de functie rlang::env_parent() kunnen gebruiken.\nx &lt;- 2\n\nf &lt;- function(){\n    x &lt;- 10\n    print(get(\"x\", envir = .GlobalEnv)) \n}\n\nf()\n\n\n\nElke programmeertaal heeft zogeheten scoping rules die bepalen vanuit welke scope men toegang heeft tot variabelen in andere scopes. In R gelden zogeheten lexicale scoping regels. Het voert te ver om deze in detail uit te werken, maar samengevat komt het erop neer dat een variabele eerst wordt opgezocht in de scope van waaruit de variabele wordt opgevraagd en vervolgens in de scope van waaruit betreffende code is gedefinieerd. Kan de variabele daar niet worden gevonden, dan wordt deze opgezocht in de naasthogere scope., etc. Als de variabele nergens gevonden kan worden geeft R een foutmelding.\nZie onderstaande voorbeeld:\n# Maak de omgeving leeg\nrm(list=ls())\n\n# Definieer een variabele 'x' en wijs de waarde 1 toe. \nx &lt;- 1\n\n# x bestaat niet in deze scope, maar wel in de bovenliggende scope waar de functie is aangemaakt:\nf &lt;- function(){ \n    print(x) \n}\n\nf()\nEen interessante vraag is wat er gebeurt wanneer een variabele niet bestaat in de functie-environment, maar wel in de enclosing-environment (de omgeving waar de functie is aangemaakt) én in de calling-environment (de omgeving van waaruit de functie wordt aangeroepen).\n\nx &lt;- 10 # We definieren x in de enclosing-environment van f1 (de globale environment)\n\nf1 &lt;- function(){\n    print(x)\n}\n\nf2 &lt;- function(){  \n    x &lt;- 20 # We herdefinieren x in de calling-environment van f1\n    f1()\n}\n\nf1() # geeft de waarde 10\nf2() # geeft de waarde 10 en _niet_ 100 (!)\n\n# Verwijder de variabele x uit de globale environment\nrm(\"x\")\n\nf1() # Deze functie geeft een fout, namelijk dat x niet is gedefinieerd. \nf2() # Ook al bestaat de variabele x in de calling-environment, de functie f1 kan deze niet benaderen. \nBovenstaande laat zien dat niet de omgeving van waaruit de functie wordt aangeroepen ertoe doet, maar de omgeving van waaruit de functie is gedefinieerd.\nVia de &lt;&lt;- operator kunnen variabelen in een bovenliggende scope worden aangemaakt en/of gewijzigd. Over het algemeen raden wij het gebruik van deze operator af, omdat dit kan leiden tot onvoorspelbare (en vaak onnavolgbare) code.\n# Maak de omgeving leeg\nrm(list = ls())\n\n# Definieer een functie die een variabele aanmaakt in de bovenliggende omgeving\nf &lt;- function(){\n    x &lt;&lt;- 1    \n}\n\n# x bestaat niet totdat we de functie uitvoeren; deze regel zou een fout moeten geven\nprint(x) \n\n# Voer de functie f uit: \nf()\n\n# x bestaat nu wel. \nprint(x)\n\n\n2.1.2 Mutabiliteit en locks (*)\nEen variabele die in R is gedefinieerd kan worden bewerkt vanuit de eigen scope, of vanuit een ondergelegen scope.\n# Veranderen waarde binnen de eigen scope\nx &lt;- 5\nx &lt;- x + 1\nprint(x)\n# Veranderen waarde vanuit onderliggende scope (af te raden!)\nx &lt;- 1\n\nf &lt;- function(){\n    x &lt;&lt;- 2\n}\n\nf()\nIn tegenstelling tot veel andere programmeertalen (bijv. Java, C#, JavaScript) heeft R niet de mogelijkheid om een variabele direct te definieren als onveranderdelijk (d.w.z., als een constante). R kent echter wel de mogelijkheid om een variabele te voorzien van een zogeheten lock. Wanneer je een dergelijke vergrendelde variabelen probeert te wijzigen, geeft R een foutmelding.\n\n\n\n\n\n\n\n\nFunctie\nOmschrijving\nVoorbeeld\n\n\n\n\nlockBinding\nVergrendel een variabele\nx &lt;- 1; lockBinding(\"x\", .globalEnv)\n\n\nunlockBinding\nOntgrendel een variabele\nx &lt;- 1; unLockBinding(\"x\", .globalEnv)\n\n\nbindingIsLocked\nControleer of een variabele vergrendeld is\nx &lt;- 1; bindingIsLocked(x)\n\n\n\n\n\n2.1.3 Dynamische types (*)\nR behoort tot de zogeheten dynamisch-getypeerde programmeertalen. Dit wil zeggen dat het datatype van variabelen in principe niet à priori vastligt en pas wordt bepaald zodra het betreffende deel van het programma wordt uitgevoerd; ook kan het type gedurende de uitvoer veranderen. Met de functie typeof kan het type van een variabele worden bepaald.\n# Voorbeeld type-conversie\ny &lt;- 1\ntypeof(y)\ny &lt;- \"test\"\ntypeof(y)\nR’s dynamische omgang met types heeft voor- en nadelen. Aan de ene kant leidt een dynamisch type-systeem tot code die kernachtig, leesbaaode, waarmee men snel en eenvoudig scripts kan maken. Aan de andere kant kan een dergelijk los systeem leiden tot code waarvan pas bij uitvoer te zeggen is wat er precies gebeurt.\nAan de hand van een simpel voorbeeld zullen we laten zien hoe we dynamische typen in ons voordeel kunnen gebruiken bij het analyseren van data. Stel dat we een vector hebben met leeftijden van personen, bijvoorbeeld x &lt;- c(40,46,70). We willen weten hoeveel personen een leeftijd groter dan 40 hebben. We kunnen dit in R als volgt uitrekenen:\nx &lt;- c(40,46,70)\nprint( sum(x &gt; 40))\nAchter de expressie sum(x &gt; 40) gaat een complexe serie bewerkingen en een onopvallende maar zeer nuttige type-conversis schuil.\nIn he volgende hoofdstuk zullen we nader ingaan op de verschillende data typen in R.\n\n\n\n\n\nflowchart TD\n    A[\"sum( x &gt; 40 )\"] --&gt; |&lt;small&gt;Vervang x&lt;/small&gt;|B[\"sum( c(40, 46, 70) &lt;b&gt;&gt; 40&lt;/b&gt; )\"]\n    B --&gt; |&lt;small&gt;Distribueer de vergelijking '&gt; 40' elementsgewijs&lt;/small&gt;|C[\"sum( c(40 &lt;b&gt;&gt; 40&lt;/b&gt;, 46 &lt;b&gt;&gt; 40&lt;/b&gt;, 70 &lt;b&gt;&gt; 40&lt;/b&gt;) )\"]\n    C --&gt; |&lt;small&gt;Evalueer de vergelijkingen&lt;/small&gt;|D[\"sum( c(&lt;b&gt;FALSE&lt;/b&gt;, &lt;b&gt;TRUE&lt;/b&gt;, &lt;b&gt;TRUE&lt;/b&gt;) )\"]\n    D --&gt; |&lt;small&gt;Converteer de logische waarden naar numerieke waarden&lt;/small&gt;|E[\"sum( c(&lt;b&gt;0&lt;/b&gt;, &lt;b&gt;1&lt;/b&gt;, &lt;b&gt;1&lt;/b&gt;) )\"]\n    E --&gt; |&lt;small&gt;Evalueer het resultaat&lt;/small&gt;|F[\"2\"] \n        \n\n\n\n\n\n\n\n\n2.1.4 Copy-on-modify semantiek(*)\nVariabelen in R kunnen verwijzen naar andere variabelen. Anders gezegd: meerdere namen kunnen in R verwijzen naar dezelfde waarden. De vraag is hoe R (intern) omgaat met een dergelijke situatie. Er zijn grofweg twee manieren waarop dit zou kunnen:\n\nCopy-on-assignment. Direct na het toewijzen van het label y aan het label x wordt een kopie van het object gemaakt.\nCopy-on-modify. Pas zodra x of y wordt bewerkt, wordt een kopie van het object in het geheugen gemaakt.\n\nR gebruikt een copy-on-modify strategie. Zie ter illustratie hoe in onderstaande voorbeeld beide variabelen x en y verwijzen naar dezelfde waarde 1. Het gaat hier niet enkel om dezelfde waarde; de namen x en y verwijzen naar hetzelfde geheugenadres. Dit kunnen we aantonen met behulp van de tracemem-functie.\nx &lt;- 1\ny &lt;- x\n\nidentical(tracemem(x), tracemem(y))\nZodra we één van de twee variabelen aanpassen, ontaat een nieuw object in het geheugen met een eigen geheugenadres.\nlibrary(data.table)\n\nx &lt;- 1\ny &lt;- x\n\nx &lt;- 2\n\nidentical(address(x), address(y))\n\nprint(x) # x = 2\nprint(y) # y = 1",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variablen, operatoren en functies.</span>"
    ]
  },
  {
    "objectID": "mod1_variables.html#functies",
    "href": "mod1_variables.html#functies",
    "title": "2  Variablen, operatoren en functies.",
    "section": "2.2 Functies",
    "text": "2.2 Functies\nEen functie is een herbruikbaar blok code dat een specifieke taak uitvoert. Functies zijn essentieel voor het opzetten van nette, herbruikbare en onderhoudbare code: ze maken het immers mogelijk complexe problemen op te splitsen in kleinere deeltaken. Een functie defineert men via de term function; met de toewijzingsoperator &lt;- kan de functie vervolgens worden toegewezen aan een naam.\nZie onderstaande voorbeeld:\n# Definieer een functie en geef deze de naam 'f'. \nf &lt;- function(x){\n    return(x+1)\n}\n\nf(1) # Geeft 1 + 1 = 2\n\nf(f(1)) # Geeft 1 + (1 + 1) = 3\nDe expressie f(1) retourneert 2. De expressie f(f(1)) past de functie twee keer toe en retourneert derhalve 3.\n\n2.2.1 Functie-argumenten\nDe argumenten vormen de input van de functie. Een functie kan 0, 1 of meerdere argumenten hebben. Argumenten kunnen een standaardwaarde hebben (een zogeheten default), maar dit hoeft niet. Argumenten kunnen een naam hebben, maar het is ook mogelijk om naamloze argumenten aan een functie mee te geven. De drie puntjes ... geven aan dat de functie nog meer argumenten kan accepteren (met naam of zonder naam).\nf &lt;- function(x, y = 1, z = NULL, ...){\n    return(x+y)\n}\n\nf(1)\n\nQuizAntwoord\n\n\n\n\n\n\n\n\n\nMet de functie formals() kun je de default-argumenten van een functie opvragen. In combinatie met de toewijzingsoperator zou je deze zelfs kunnen aanpassen:\nformals(sd) &lt;- alist(x = , na.rm = TRUE) # Werkt, maar gevaarlijk (!)\nOver het algemeen raden we bovenstaande werkwijze af, want het wijzigen van de werking van bestaande functies kan leiden tot onvoorspelbaar gedrag, bijvoorbeeld in andere functies die van de door ons gewijzigde functie afhankelijk zijn. Veiliger is het om een nieuwe functie te maken die de oude functie aanroept, maar dan met gewijzigde default argumenten.\nsd.valid &lt;- sd\nformals(sd.valid) &lt;- alist(x = , na.rm = TRUE)\nArgumenten van functies kunnen berekeningen bevatten, eventueel met verwijzingen naar andere functie-argumenten. Zie onderstaande voorbeelden:\nf &lt;- function(x, y, z = y + 1){\n    return(x + 1)\n}\n\nf(x = 1) \nf(x = 1, y = 2)\nf(y = 2) # Deze geeft een foutmelding; de waarde x is namelijk nodig binnen de functie. \n\n\n2.2.2 Lazy evaluation\nWellicht vraag je je af hoe je bij het definieren van het argument z kunt verwijzen naar de waarde y, terwijl deze waarde nog niet bekend is. Bedenk dat in R geldt dat functieargumenten pas worden geëvalueerd zodra ze binnen de context van de functie worden gebruikt. Dit heet ook wel lazy-evaluation.\n\n\n2.2.3 Controleren van argumenten: match.arg\nEen veelvoorkomende techniek is om standaardwaarden te controleren aan de hand van een lijst met standaardwaarden. Dit geschiedt met de functie match.arg.\nZie onderstaande voorbeeld:\nf &lt;- function(x = c(\"a\",\"b\",\"c\"){\n    x &lt;- match.arg(x)\n    print(x)\n}\n\nf(\"a\")\nf(\"fout\") # Dit geeft een foutmelding\n\n\n2.2.4 Pure functies en side-effects\nEen functie kan een resultaat teruggeven, een handeling uitvoeren (een zogeheten bijwerking of side-effect), of beide. Een functie zonder side-effects is een zogeheten pure functie. In Module 4 zullen deze pure-functies uitvoerig aan bod komen.\n\n\n2.2.5 Functies en scope\nEen functie heeft toegang tot alle variabelen die gedefiniëerd zijn binnen de environment van waaruit de functie is aangemaakt (de zogeheten enclosing-environment).\n\n\n2.2.6 Functies als argument\nIn R is het mogelijk functies als argument mee te geven aan een andere functie.\n# Definieer een lijst van functies 'funcs' toepast over een vector x. \n\ndescribe &lt;- function(x, fs){\n    lapply(fs, function(f){\n        f(x)\n    })\n}\n\nx  &lt;- c(1,2,3,4,5,6,7)\nfs &lt;- list(m = mean, s = sd)\n\ndescribe(x, fs)\nBij het opzetten van Shiny dashboards zullen we handig gebruik maken van deze krachtige mogelijkheid van R.",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variablen, operatoren en functies.</span>"
    ]
  },
  {
    "objectID": "mod1_variables.html#operatoren",
    "href": "mod1_variables.html#operatoren",
    "title": "2  Variablen, operatoren en functies.",
    "section": "2.3 Operatoren",
    "text": "2.3 Operatoren\nEen operator is een bewerking (operatie) op één of twee input-elementen. Operatoren kunnen worden ingedeeld in unaire operatoren (één input) en binaire operatoren (twee inputs). De input van een unaire operator staat aan de rechterhandszijde (RHZ) van de operator:\n# Voorbeeld van een negatie-operator '!'\nx &lt;- TRUE\ny &lt;- !x  \nprint(y)\nDe inputs van een binaire operators staan aan de linkerhandszijde (LHZ) en rechterhandszijde (RHZ) van de operator:\nx &lt;- 1        #LHZ\ny &lt;- 2        #RHZ\nz &lt;- x + y \nOnderstaande diagram vat de meest voorkomende operatoren in R samen:\n\n\n\n\n\nflowchart TD\n   X[Operators] --&gt; |&lt;small&gt;Eén input&lt;/small&gt;| U[Unair]\n   X --&gt; |&lt;small&gt;Twee inputs&lt;/small&gt;|B[Binair]\n   U --&gt; |&lt;small&gt;Help&lt;/small&gt;|H[\"?, ??\"]\n   U --&gt; |&lt;small&gt;Negatie&lt;/small&gt;|N[\"!\"] \n   B --&gt; |&lt;small&gt;Toewijzing&lt;/small&gt;|A[\"&lt;-, &lt;&lt;-, -&gt;, -&gt;&gt;, =\"]\n   B --&gt; |&lt;small&gt;Extractie&lt;/small&gt;|EX[\"[, [[\"]\n   B --&gt; |&lt;small&gt;Logisch&lt;/small&gt;|LO[\"&, &&, |, ||\"]\n   B --&gt; |&lt;small&gt;Vergelijken&lt;/small&gt;|COM[\"&lt;, &lt;=, &gt;, &gt;=, ==, !=\"]\n   B --&gt; |&lt;small&gt;Rekenkundig&lt;/small&gt;|AR[\"+, -, /, ^, ...\"]\n   B --&gt; |&lt;small&gt;Speciaal&lt;/small&gt;|CUST[\"%any%, %in%\"]\n\n\n\n\n\n\nVoorbeelden:\nx &lt;- 1 # Toewijzen label 'x' aan waarde '1' in het geheugen \ny &lt;- 2 # idem. \n\n# Binaire operatoren: \nz &lt;- x + y # Optellen\nd &lt;- x * y # Vermenigvuldigen\n\nQuizAntwoord\n\n\nZie de vector x &lt;- c(1, 2, 3) en y &lt;- c(3, 2, 1).\n\nMaak een logische vector p die voor elke paarsgewijze vergelijking tussen x en y aangeeft of het element uit x groter is dan het corresponderende element uit y.\n\n\n\nZie de vector x &lt;- c(1, 2, 3) en y &lt;- c(3, 2, 1).\n\nMaak een logische vector p die voor elke paarsgewijze vergelijking tussen x en y aangeeft of het element uit x groter is dan het corresponderende element uit y.\n\np &lt;- x &gt; y\n\n\n\n\n\n\n2.3.1 Volgorde van bewerkingen\nBij complexe berekeningen is het belangrijk om te weten in welke volgorde de programmeertaal bepaalde bewerkingen uitvoert. De berekening \\(1 + 2 / 3\\) is immers niet hetzelfde als \\(1 + (2 /3)\\).\nZie de documentatie in ?syntax voor een uitgebreide bespreking van de volgorde van bewerkingen in R.\nProbeer na te gaan in welke volgorde onderstaande bewerkingen worden uitgevoerd:\nx &lt;- 5 + 5 -&gt; y\n\nQuizAntwoord\n\n\nZie de expressie y &lt;- (x &lt;- 1) + 3.\n\nIs dit geldige R?\nZo ja, wat is het resultaat?\n\n\n\nZie de expressie y &lt;- (x &lt;- 1) + 3.\n\nIs dit geldige R?\n\nJa. Dit is (verbazingwekkend genoeg) geldige R code.\n\nZo ja, wat is het resultaat?\n\nEerst wordt x gelijk gesteld aan 1. Daarna wordt er drie bij opgeteld. Het resultaat wordt vervolgens toegewezen aan de naam y.\n\n\n\n\n\n\n\n2.3.2 Pipe-operatoren\nDe zogeheten pipe-operator %&gt;% uit het magrittr-package is een operator waarmee bewerkingen sequentieel uitgevoerd kunnen worden. In tidyverse, plotly en shiny wordt deze operator veelvuldig gebruikt om complexe functie-aanroepen te vereenvoudigen. In Module 4 zullen we hier nader op in gaan.",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variablen, operatoren en functies.</span>"
    ]
  },
  {
    "objectID": "mod1_datatypes.html",
    "href": "mod1_datatypes.html",
    "title": "3  Data types",
    "section": "",
    "text": "3.1 Vectorisatie\nIn R is alles een vector. Ook enkelvoudige waarden, zoals een enkel getal (x &lt;- 1) of een enkelvoudige tekst (y &lt;- \"test\"), worden behandeld als vectoren met lengte één. Dit is een fundamenteel aspect van R en heeft grote invloed op hoe de taal werkt. Zeker voor degenen die (meer) ervaring hebben met talen zoals Python, C# of Javascript is het van belang dit fundamentale aspect van R voor het netvlies te hebben.\nZie ter illustratie onderstaande codevoorbeelden in JavaScript en R, waarin we aan elk element van een serie getallen 1, 2, 3, 4, 5) het getal 1 willen optellen. In JavaScript zou je zoiets kunnen oplossen met behulp van een for-loop over alle elementen van een array. in R kun je de berekening op een directe manier opschrijven.\nLaten we eens nader bezien wat er genlijk gebeurt bij de (schijnbaar) eenvoudige expressie c(1,2,3,4,5) + 1. Conceptueel gebeurt er het volgende:\nflowchart TD\n    A[\"c(1, 2, 3, 4, 5) + &lt;b&gt;1&lt;/b&gt;\"] --&gt; |Recycle 1 om te conformeren aan de linkervector|B[\"c(1, 2, 3, 4, 5) + c(&lt;b&gt;1&lt;/b&gt; ,&lt;b&gt;1&lt;/b&gt; ,&lt;b&gt;1&lt;/b&gt; ,&lt;b&gt;1&lt;/b&gt; ,&lt;b&gt;1&lt;/b&gt;)\"]\n    B --&gt; |Tel de vectoren elementsgewijs op|C[\"c(1+&lt;b&gt;1&lt;/b&gt;, 2+&lt;b&gt;1&lt;/b&gt;, 3+&lt;b&gt;1&lt;/b&gt;, 4+&lt;b&gt;1&lt;/b&gt;, 5+&lt;b&gt;1&lt;/b&gt;)\"]\n    C --&gt; |Evalueer elementsgewijs het resultaat|D[\"c(2, 3, 4, 5, 6)\"]\nMerk op dat er in R niet zoiets bestaat als een ‘los’ getal 1. Dit getal is eigenlijk een vector met lengte 1, met als eerste (en enige) element het getal 1.\nBij het optellen van twee vectoren in R worden de beide vectoren eerst gelijkgemaakt in lengte en type.\nIn R kunnen data types impliciet en expliciet worden geconverteerd. Impliciete conversie vindt plaats bij berekeningen op twee data typen die op het eerste gezicht onverenigbaar lijken.",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data types</span>"
    ]
  },
  {
    "objectID": "mod1_datatypes.html#vectorisatie",
    "href": "mod1_datatypes.html#vectorisatie",
    "title": "3  Data types",
    "section": "",
    "text": "Javascript\n\n\nR\n\n\n\n\nlet x = [1, 2, 3, 4, 5];\n\nfor(i = 0; i &lt; x.length; i++) {\n   x[i] += 1;\n}\n\nconsole.log(x);\n\n\nx &lt;- c(1,2,3,4,5)\n\nx &lt;- x + 1\n\n\n\nprint(x);\n\n\n\n\n\n\n\n\nGelijkmaken van lengte geschiedt door de kortste vector net zo vaak te vermenigvuldigen totdat deze in de langere vector ‘past’ (recycling)\nGelijkmakten van data-types geschiedt via zogeheten dataconversie-regels (coercion).\n\n\n\nQuizAntwoord\n\n\nWe definiëren de variabelen x en y als volgt:\nx &lt;- c(0,1,2)\ny &lt;- c(TRUE,TRUE,TRUE) \nWat leveren onderstaande expressies op? Geef aan van wat voor type het resultaat is en wat de daadwerkelijke uitkomst is.\n\n\n\nExpressie\nType\nUitkomst\n\n\n\n\nx == y\n…\n…\n\n\nx | y\n…\n…\n\n\nx & y\n…\n…\n\n\nx + y\n…\n…\n\n\n\n\n\nWe definiëren de variabelen x en y als volgt:\nx &lt;- c(0,1,2)\ny &lt;- c(TRUE,TRUE,TRUE) \nWat leveren onderstaande expressies op? Geef aan van wat voor type het resultaat is en wat de daadwerkelijke uitkomst is.\n\n\n\nExpressie\nType\nUitkomst\n\n\n\n\nx == y\nLogische vector\nFALSE, TRUE, FALSE\n\n\nx | y\nLogische vector\nTRUE, TRUE, TRUE\n\n\nx & y\nLogische vector\nFALSE, TRUE, TRUE\n\n\nx + y\nNumerieke vector\n1, 2, 3",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data types</span>"
    ]
  },
  {
    "objectID": "mod1_datatypes.html#atomische-vectoren",
    "href": "mod1_datatypes.html#atomische-vectoren",
    "title": "3  Data types",
    "section": "3.2 Atomische vectoren",
    "text": "3.2 Atomische vectoren\nAtomische vectoren zijn de bouwstenen van meer complexe datastructuren in R. Een atomische vector bevat enkelvoudige data-types die slechts één enkele waarde of element bevatten. R kent verschillende typen vectoren, waaronder logische vectoren, numerieke vectoren (onderverdeeld in integers en doubles), complexe vectoren en karakter-vectoren (character).\n\n\n\n\n\n flowchart TD\n        B[Atomische vector] --&gt; L[Logisch]\n        B --&gt; N[Numeriek]\n        N --&gt; I[Integer]\n        N --&gt; D[Double]\n        B --&gt; Z[Complex]  \n        B --&gt; C[Character]\n        B --&gt; R[Raw]\n       \n\n\n\n\n\n\nEr zijn verschillende manieren om een vector aan te maken. Een expliciete (en niet veel gebruikte) methode is via de vector() functie; gangbaarder is om de functie c() te gebruiken. Een impliciete manier is om een vector te definiëren als het resultaat van een berekening.\n\nQuizAntwoord\n\n\nWe definiëren de variabelen x en y als volgt:\nx &lt;- c(1, 2, 3)\ny &lt;- c(TRUE, FALSE, FALSE)\nz &lt;- c(\"a\", \"b\", \"c\")\nWat leveren onderstaande expressies op? Geef aan van wat voor type het resultaat is en wat de uitkomst is.\n\n\n\nExpressie\nType\nUitkomst\n\n\n\n\nc(x,y)\n…\n…\n\n\nc(x,z)\n…\n…\n\n\nc(y,z)\n…\n…\n\n\n\n\n\nWe definiëren de variabelen x en y als volgt:\nx &lt;- c(1, 2, 3)\ny &lt;- c(TRUE, FALSE, FALSE)\nz &lt;- c(\"a\", \"b\", \"c\")\nWat leveren onderstaande expressies op? Geef aan van wat voor type het resultaat is en wat de uitkomst is.\n\n\n\n\n\n\n\n\nExpressie\nType\nUitkomst\n\n\n\n\nc(x,y)\nvector van doubles\n1, 2, 3, 1, 0, 0\n\n\nc(x,z)\nvector van characters\n\"1\", \"2\", \"3\", \"a\", \"b\", \"c\"\n\n\nc(y,z)\nvector van doubles\n\"TRUE\", \"FALSE\", \"FALSE\", \"a\", \"b\", \"c\"",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data types</span>"
    ]
  },
  {
    "objectID": "mod1_datatypes.html#attributen",
    "href": "mod1_datatypes.html#attributen",
    "title": "3  Data types",
    "section": "3.3 Attributen",
    "text": "3.3 Attributen\nAan elk R-object kan meta-data worden toegevoegd via zogeheten attributen. Een R-object kan een willekeurige set van attributen hebben, waaronder dimensies (waardoor vectoren matrices en arrays worden), klasse (gebruikt voor S3 objectgeoriënteerd programmeren), namen (voor het benoemen van elementen van vectoren en lijsten), of andere door gebruikers gedefinieerde metadata.\nAttributen kunnen worden benaderd met de attr() functie om een attribuut direct te krijgen of in te stellen. Zo haalt attr(object, \"naam\") de waarde van het attribuut van op, en stelt attr(object, \"attribute_name\") &lt;- waarde de attribuutwaarde in. De attributes() functie geeft een lijst terug van alle attributen van een object, en attributes(object) &lt;- list(attribute_name = waarde, ...) kan worden gebruikt om meerdere attributen tegelijk in te stellen.\nAttributen moeten zorgvuldig worden beheerd, aangezien het wijzigen ervan de manier kan veranderen waarop een object wordt behandeld door functies en kan leiden tot onbedoelde resultaten als ze niet correct worden behandeld.\nx &lt;- c(1,2,3)\n\n# Voeg een attribuut \"omschrijving\" toe aan het object 'x' met als waarde 'test'. \nattr(x, \"omschrijving\") &lt;- \"test\"\n\n# Het printen van het object x zorgt ervoor dat ook de attribuut-waarden worden geprint: \nprint(x)",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data types</span>"
    ]
  },
  {
    "objectID": "mod1_datatypes.html#matrices-en-arrays",
    "href": "mod1_datatypes.html#matrices-en-arrays",
    "title": "3  Data types",
    "section": "3.4 Matrices en Arrays",
    "text": "3.4 Matrices en Arrays\nEen matrix is een tweedimensionele datastructuur die gebruikt kan worden om wiskundige berekeningen te vereenvoudigen. Een array is een meerdimensionale generalisatie van een matrix. Matrices en arrays zijn in R niks anders dan atomische vectoren waaraan een zogeheten dimensie-attribuut (dim) is toegevoegd.\nEen matrix kan worden aangemaakt door een vector te voorzien van het dimensie-attribuut dim, door de matrix-functie aan te roepen, of als resultaat van een andere berekening die een matrix retourneert (bijvoorbeeld de functie diag() die een identiteitsmatrix oplevert.\nZie onderstaande voorbeeld:\n# Maak een matrix x aan door het dim-attribuut in te stellen: \nx &lt;- c(1,2,3,4)\ndim(x) &lt;- c(2,2)\n\n# Maak een matrix aan met het (expliciete) matrix-commando: \ny &lt;- matrix(x, nrow = 2)\n\n# Verifieer dat beide matrices gelijk aan elkaar zijn: \nidentical(x,y)\n\nQuizAntwoord\n\n\nProbeer de volgende matrices te construeren:\n\nEen 2 x 3-matrix met de getallen 1 tot en met 6, opgeslagen als integer data type.\n\n\\[\n\\begin{bmatrix}\n1  & 3 & 5 \\\\\n2  & 4 & 6\n\\end{bmatrix}\n\\]\n\nEen 3 x 3-identiteitsmatrix\n\n\\[\n\\begin{bmatrix}\n1  & 0 & 0 \\\\\n0  & 1 & 0 \\\\\n0  & 0 & 1\n\\end{bmatrix}\n\\]\n\n\nProbeer de volgende matrices te construeren:\n\nEen 2 x 3-matrix met de getallen 1 tot en met 6, gerepresenteerd als integer data type.\n\n  # Methode 1\n  x &lt;- matrix(as.integer(1:6), nrow = 2)\n  \n  # Methode 2\n  y &lt;- as.integer(1:6)\n  attr(y, \"dim\") &lt;- c(2,3)\n\nEen 3 x 3-identiteitsmatrix\n\n  # Methode 1\n  x &lt;- matrix(rep(0, 9)), nrow = 3)\n  \n  # Methode 2\n  y &lt;- 0 * diag(3)\n\n\n\nR kan wiskundige berekeningen uitvoeren op matrices mits de matrices conformeren naar voor de betreffende berekening geldige dimensies.\nEnkele voorbeelden:\n\nDe rekenkundige operatoren +, -, * en / werken op elk van de elementen van twee matrices, mits deze conformeren.\nDe operator %*% geeft het matrixproduct tussen twee matrices.\nDe functie diag(x) geeft de diagonaal van de (vierkante) matrix x.\nDe functie solve(x) geeft de inverse van de matrix x.\nDe functie t(x) geeft de matrixtranspositie van x.\n\n\nQuizAntwoord\n\n\nBereken het matrixproduct \\(A * B\\) van de volgende matrices:\n\\[\nA = \\begin{bmatrix}\n1  & 3 & 5 \\\\\n2  & 4 & 6\n\\end{bmatrix},\nB = \\begin{bmatrix}\n1 & 2  \\\\\n3 & 4   \\\\\n5 & 6\n\\end{bmatrix}\n\\]\n\n\nBereken het matrix-product \\(A * B\\) van de volgende matrices:\n\\[\nA = \\begin{bmatrix}\n1  & 3 & 5 \\\\\n2  & 4 & 6\n\\end{bmatrix},\nB = \\begin{bmatrix}\n1 & 2  \\\\\n3 & 4   \\\\\n5 & 6\n\\end{bmatrix}\n\\]\n# We definieren de matrix A als volgt:\nA &lt;- matrix(c(1,2,3,4,5,6), nrow = 2)\n\n# Merk op dat B de transpositie van A is: \nB &lt;- t(A) \n\n# Het beoogde resultaat: \nA %*% B",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data types</span>"
    ]
  },
  {
    "objectID": "mod1_datatypes.html#lijsten",
    "href": "mod1_datatypes.html#lijsten",
    "title": "3  Data types",
    "section": "3.5 Lijsten",
    "text": "3.5 Lijsten\nLijsten zijn vectoren waarbij de elementen niet van hetzelfde type hoeven te zijn. Een lijst kan op verschillende manieren aangemaakt worden. Gangbare methoden zijn de list() functie uit R, de functie list2() uit het rlang-package, door het combineren van lijsten via de functie c(), of als uitkomst van een functie die een lijst retourneert (bijv. lapply) of as.list(). De functie names() retourneert de namen van een lijst; deze functie kan gebruikt worden in combinatie met de toewijzingsoperator &lt;-.\n\nQuizAntwoord\n\n\nZie onderstaande lijst x met toetsresultaten.\n\nMaak een nieuwe lijst y met het gemiddelde resultaat voor elk van de personen in x.\n\nVerander de namen van de lijst in kleine letters (gebruik hiervoor de functie tolower()).\n\nx &lt;- list(\n    Jan = c(10, 4, 2), \n    Piet = c(5),\n    Gijs = c(8,9,10)\n)\n\n\nZie onderstaande lijst x met toetsresultaten.\n\nMaak een nieuwe lijst y met het gemiddelde resultaat voor elk van de personen in x.\n\nVerander de namen van de lijst in kleine letters (gebruik hiervoor de functie tolower()).\n\nx &lt;- list(\n    Jan = c(10, 4, 2), \n    Piet = c(5),\n    Gijs = c(8,9,10)\n)\n\n# Gebruik de lapply functie in combinatie met de 'mean' functie. \ny &lt;- lapply(x, mean)\n\n# Gebruik de functie 'names' in combinatie met de toewijzingsoperator &lt;- om de namen te wijzigen: \nnames(y) &lt;- tolower(names(y))",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data types</span>"
    ]
  },
  {
    "objectID": "mod1_subsetting.html",
    "href": "mod1_subsetting.html",
    "title": "4  Sets en subsets",
    "section": "",
    "text": "4.1 Subsetten van atomische vectoren\nHet subsetten van een atomische vector levert een nieuwe atomische vector op van hetzelfde type als de originele vector. Subsetten kan worden gebruikt om een selectie van elementen te maken en deze aan een nieuwe vector toe te wijzen (selecteren), of om elementen van een bestaande datastructuur te wijzigen.\nEr zijn verschillende manieren om elementen te selecteren uit een atomische vector.\nLet op bij het gebruik van indices: in R geldt dat het eerste element op positie 1 staat (en niet op positie 0, zoals in veel andere programmeertalen gebruikelijk is. Het is mogelijk een element meer dan één keer te selecteren door de index te herhalen.",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sets en subsets</span>"
    ]
  },
  {
    "objectID": "mod1_subsetting.html#subsetten-van-atomische-vectoren",
    "href": "mod1_subsetting.html#subsetten-van-atomische-vectoren",
    "title": "4  Sets en subsets",
    "section": "",
    "text": "Positieve indices geven aan welke elementen wél in de selectie dienen te vallen.\nNegatieve indices geven aan welke elementen niet in de selectie dienen te vallen.\nLogische waarden geven aan of een element wel (TRUE) of niet (FALSE) in de selectie dient te vallen.\nNamen geven aan welk element wél in de selectie dient te vallen.\n\n\n\nQuizAntwoord\n\n\nZie de vector x &lt;- c(10, 20, 30, 40, 50).\n\nMaak een vector p met enkel de eerste drie elementen.\nMaak een vector q zonder de eerste twee elementen.\nMaak een vector r met alle elementen groter dan 30.\nMaak een vector s met drie keer het eerste element uit x.\n\n\n\nZie de vector x &lt;- c(10, 20, 30, 40, 50).\n\nMaak een vector p met enkel de eerste drie elementen.\n\np &lt;- x[c(1:3)]\n\nMaak een vector q zonder de eerste twee elementen.\n\nq &lt;- x[-c(1:2)]\n\nMaak een vector r met alle elementen groter dan 30.\n\nr &lt;- x[which(x &gt; 30)]\n\nMaak een vector s met drie keer het eerste element uit x.\n\ns &lt;- x[c(1,1,1)]",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sets en subsets</span>"
    ]
  },
  {
    "objectID": "mod1_subsetting.html#subsetten-van-lijsten",
    "href": "mod1_subsetting.html#subsetten-van-lijsten",
    "title": "4  Sets en subsets",
    "section": "4.2 Subsetten van lijsten",
    "text": "4.2 Subsetten van lijsten\nHet selecteren van elementen uit lijsten geschiedt op gelijksoortige wijzen als het subsetten van atomische vectoren. Er bestaat echter een belangrijk verschil tussen de operator [ en [[.\n\n[ retourneert een lijst van alle geselecteerde elementen\n[[ retourneert één element uit een lijst\n\n\nQuizAntwoord\n\n\nZie de lijst x &lt;- list(a = \"Jan\", b = \"Piet\").\nLeg uit wat het verschil is tussen x[\"a\"] en x[[\"a\"]]\n\n\nZie de lijst x &lt;- list(a = \"Jan\", b = \"Piet\").\nLeg uit wat het verschil is tussen x[\"a\"] en x[[\"a\"]]\nBeide bewerkingen selecteren “Jan”, maar x[\"a\"] levert een lijst met het element “Jan”, terwijl x[[\"a\"]] de waarde “Jan” levert",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sets en subsets</span>"
    ]
  },
  {
    "objectID": "mod1_subsetting.html#vergelijken-en-combineren-van-sets",
    "href": "mod1_subsetting.html#vergelijken-en-combineren-van-sets",
    "title": "4  Sets en subsets",
    "section": "4.3 Vergelijken en combineren van sets",
    "text": "4.3 Vergelijken en combineren van sets\nR kent een aantal functies die het combineren van sets mogelijk maakt.\n\n\n\n\n\n\n\nFunctie\nOmschrijving\n\n\n\n\nintersect(x,y)\nGeef alle elementen die zowel in x als y voorkomen\n\n\nunion(x,y)\nGeef alle elementen die in x óf in y voorkomen\n\n\nunique(x)\nGeef alle unieke elementen in x\n\n\nsetdiff(x, y)\nGeef het verschil tussen de vector x en y, dat wil zeggen: alle elementen die",
    "crumbs": [
      "Module 1 - Basis R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sets en subsets</span>"
    ]
  }
]